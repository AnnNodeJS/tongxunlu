/**
 * 全局通用的JS
 */
//接口服务器
var server = "http://api.sharecarding.com";
//应用介绍页
var downloadurl = "http://a.app.qq.com/o/simple.jsp?pkgname=com.ruby.sharecarding";

function getToken(cb){
	plus.io.resolveLocalFileSystemURL( "_doc/sharecarding/token.data", function( entry ) {
		// 可通过entry对象操作test.html文件 
		entry.file( function(file){
			var fileReader = new plus.io.FileReader();
			fileReader.readAsText(file, 'utf-8');
			fileReader.onloadend = function(evt) {
				var token = evt.target.result;
				cb(token);
			}
		} );
	}, function ( e ) {
		token = "";
		cb(token);
	} );
};

function setToken(token){
	plus.io.resolveLocalFileSystemURL( "_doc", function( entry ) {
		entry.getDirectory( "sharecarding", {create:true,exclusive:false}, function( dir ){
			dir.getFile('token.data',{create:true}, function(fileEntry){
				if(token == '-1'){
					fileEntry.remove();
				}else{
					// 可通过entry对象操作test.html文件 
					fileEntry.createWriter( function ( writer ) {
						// Write data to file.
						writer.write( token );
					}, function ( e ) {
						alert( e.message );
					} );
				}
			});
		}, function () {
			alert( e.message );
		} );
	}, function ( e ) {
		alert( "Resolve file URL failed: " + e.message );
	} );
}

//提取手机号
function get_mobile(str){ 
	if(str.length>0){
		while(str.indexOf(" ")!=-1){
 			str=str.replace(" ","");
		}
	    str = str.replace(/-/g,"");
	    str = str.replace("+86","");
	    var mobileExp = new RegExp("^[1][3-8]\\d{9}$");
	    if(mobileExp.test(str)){
	        return str;
	    }
	}
	return "";
}

function sortNumbers($contacts){
	//最终的字符串结果
	var contactors = "";
    var result = [], isRepeated;
    for (var i = 0, len = $contacts.length; i < len; i++) {
        isRepeated = true;
		var contactor = $contacts[i];
		if(contactor.phoneNumbers[0]){
			var phones = get_mobile(contactor.phoneNumbers[0].value);
			if(phones.length>0){
				isRepeated = false;
		        for (var j = 0, len2 = result.length; j < len2; j++) {
		            if (phones == result[j][1]) {   
		                isRepeated = true;
		                break;
		            }
		        }
		        if (!isRepeated) {
		        	var tmp_arr = [];
		        	tmp_arr[0] = contactor.displayName;
		        	tmp_arr[1] = phones;
		            result.push(tmp_arr);
		        }
			}
		}
    }
	for(var i in result){
		var contactor = result[i];
		if(contactor[1]){
			var phones = get_mobile(contactor[1]);
			if(phones.length>0){
				contactors += contactor[0] + ":" + phones + "|";
			}
		}
	}
	return contactors;
}

//姓名验证              
function check_surname(str) { 
	if(str.length>3){
		return false;
	}
    var str = str.substr(0, 1); //截取用户提交的用户名的前两字节，也就是姓。   
    var surname = " 赵钱孙李周吴郑王冯陈褚卫蒋沈韩杨朱秦尤许何吕施张孔曹严华金魏陶姜戚谢邹喻柏水窦章云苏潘葛奚范彭郎鲁韦昌马苗凤花方俞任袁柳酆鲍史唐费廉岑薛雷贺倪汤 滕殷罗毕郝邬安常乐于时傅皮卞齐康伍余元卜顾孟平黄和穆萧尹姚邵堪汪祁毛禹狄米贝明臧计伏成戴谈宋茅庞熊纪舒屈项祝董粱杜阮蓝闵席季麻强贾路娄危江童颜郭 梅盛林刁钟徐邱骆高夏蔡田樊胡凌霍虞万支柯咎管卢莫经房裘缪干解应宗宣丁贲邓郁单杭洪包诸左石崔吉钮龚程嵇邢滑裴陆荣翁荀羊於惠甄魏加封芮羿储靳汲邴糜松 井段富巫乌焦巴弓牧隗山谷车侯宓蓬全郗班仰秋仲伊宫宁仇栾暴甘钭厉戎祖武符刘姜詹束龙叶幸司韶郜黎蓟薄印宿白怀蒲台从鄂索咸籍赖卓蔺屠蒙池乔阴郁胥能苍双 闻莘党翟谭贡劳逄姬申扶堵冉宰郦雍郤璩桑桂濮牛寿通边扈燕冀郏浦尚农温别庄晏柴瞿阎充慕连茹习宦艾鱼容向古易慎戈廖庚终暨居衡步都耿满弘匡国文寇广禄阙东 殴殳沃利蔚越夔隆师巩厍聂晁勾敖融冷訾辛阚那简饶空曾毋沙乜养鞠须丰巢关蒯相查后江红游竺权逯盖益桓公万俟司马上官欧阳夏侯诸葛闻人东方赫连皇甫尉迟公羊 澹台公冶宗政濮阳淳于仲孙太叔申屠公孙乐正轩辕令狐钟离闾丘长孙慕容鲜于宇文司徒司空亓官司寇仉督子车颛孙端木巫马公西漆雕乐正壤驷公良拓拔夹谷宰父谷粱 晋楚闫法汝鄢涂钦段干百里东郭南门呼延妫海羊舌微生岳帅缑亢况後有琴梁丘左丘东门西门商牟佘佴伯赏南宫墨哈谯笪年爱阳佟第五言福";  
    r = surname.search(str); // 查找字符串。  
    if (r == -1) {  
        return false;  
    }  
    else{  
        return true;  
    }  
}  

/*
根据〖中华人民共和国国家标准 GB 11643-1999〗中有关公民身份号码的规定，公民身份号码是特征组合码，由十七位数字本体码和一位数字校验码组成。排列顺序从左至右依次为：六位数字地址码，八位数字出生日期码，三位数字顺序码和一位数字校验码。
    地址码表示编码对象常住户口所在县(市、旗、区)的行政区划代码。
    出生日期码表示编码对象出生的年、月、日，其中年份用四位数字表示，年、月、日之间不用分隔符。
    顺序码表示同一地址码所标识的区域范围内，对同年、月、日出生的人员编定的顺序号。顺序码的奇数分给男性，偶数分给女性。
    校验码是根据前面十七位数字码，按照ISO 7064:1983.MOD 11-2校验码计算出来的检验码。

出生日期计算方法。
    15位的身份证编码首先把出生年扩展为4位，简单的就是增加一个19或18,这样就包含了所有1800-1999年出生的人;
    2000年后出生的肯定都是18位的了没有这个烦恼，至于1800年前出生的,那啥那时应该还没身份证号这个东东，⊙﹏⊙b汗...
下面是正则表达式:
 出生日期1800-2099  (18|19|20)?\d{2}(0[1-9]|1[12])(0[1-9]|[12]\d|3[01])
 身份证正则表达式 /^\d{6}(18|19|20)?\d{2}(0[1-9]|1[12])(0[1-9]|[12]\d|3[01])\d{3}(\d|X)$/i            
 15位校验规则 6位地址编码+6位出生日期+3位顺序号
 18位校验规则 6位地址编码+8位出生日期+3位顺序号+1位校验位
 
 校验位规则     公式:∑(ai×Wi)(mod 11)……………………………………(1)
                公式(1)中： 
                i----表示号码字符从由至左包括校验码在内的位置序号； 
                ai----表示第i位置上的号码字符值； 
                Wi----示第i位置上的加权因子，其数值依据公式Wi=2^(n-1）(mod 11)计算得出。
                i 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1
                Wi 7 9 10 5 8 4 2 1 6 3 7 9 10 5 8 4 2 1

*/
//身份证号合法性验证 
//支持15位和18位身份证号
//支持地址编码、出生日期、校验位验证
function IdentityCodeValid(code) { 
    var city={11:"北京",12:"天津",13:"河北",14:"山西",15:"内蒙古",21:"辽宁",22:"吉林",23:"黑龙江 ",31:"上海",32:"江苏",33:"浙江",34:"安徽",35:"福建",36:"江西",37:"山东",41:"河南",42:"湖北 ",43:"湖南",44:"广东",45:"广西",46:"海南",50:"重庆",51:"四川",52:"贵州",53:"云南",54:"西藏 ",61:"陕西",62:"甘肃",63:"青海",64:"宁夏",65:"新疆",71:"台湾",81:"香港",82:"澳门",91:"国外 "};
    var tip = "";
    var pass= true;
    
    if(!code || !/^\d{6}(18|19|20)?\d{2}(0[1-9]|1[12])(0[1-9]|[12]\d|3[01])\d{3}(\d|X)$/i.test(code)){
        tip = "身份证号格式错误";
        pass = false;
    }
    
   else if(!city[code.substr(0,2)]){
        tip = "地址编码错误";
        pass = false;
    }
    else{
        //18位身份证需要验证最后一位校验位
        if(code.length == 18){
            code = code.split('');
            //∑(ai×Wi)(mod 11)
            //加权因子
            var factor = [ 7, 9, 10, 5, 8, 4, 2, 1, 6, 3, 7, 9, 10, 5, 8, 4, 2 ];
            //校验位
            var parity = [ 1, 0, 'X', 9, 8, 7, 6, 5, 4, 3, 2 ];
            var sum = 0;
            var ai = 0;
            var wi = 0;
            for (var i = 0; i < 17; i++)
            {
                ai = code[i];
                wi = factor[i];
                sum += ai * wi;
            }
            var last = parity[sum % 11];
            if(parity[sum % 11] != code[17]){
                tip = "校验位错误";
                pass =false;
            }
        }
    }
    return pass;
}